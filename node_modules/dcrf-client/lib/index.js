"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const autobind_decorator_1 = __importDefault(require("autobind-decorator"));
const loglevel_1 = require("loglevel");
const UUID_1 = __importDefault(require("./lib/UUID"));
const subscriptions_1 = require("./subscriptions");
const fifo_1 = __importDefault(require("./dispatchers/fifo"));
const websocket_1 = __importDefault(require("./transports/websocket"));
const fifo_2 = __importDefault(require("./send_queues/fifo"));
const json_1 = __importDefault(require("./serializers/json"));
const log = loglevel_1.getLogger('dcrf');
class DCRFClient {
    /**
     * @param dispatcher Dispatcher instance to route incoming frames to associated handlers
     * @param transport Transport to send and receive messages over the wire.
     * @param queue Instance of Queue to queue messages when transport unavailable.
     * @param serializer Instance which handles serializing data to be sent, and
     *                   deserializing received data.
     * @param options Configuration to customize how DCRFClient operates. See
     *                the IDCRFOptions type for more information.
     */
    constructor(dispatcher, transport, queue, serializer, options = {}) {
        this.dispatcher = dispatcher;
        this.transport = transport;
        this.queue = queue;
        this.serializer = serializer;
        this.options = options;
        this.queue.initialize(this.transport.send, this.transport.isConnected);
        this.subscriptions = {};
    }
    initialize() {
        this.transport.connect();
        this.transport.on('message', this.handleTransportMessage);
        this.transport.on('connect', this.handleTransportConnect);
        this.transport.on('reconnect', this.handleTransportReconnect);
    }
    list(stream, data = {}, requestId) {
        return this.request(stream, {
            action: 'list',
            data,
        }, requestId);
    }
    create(stream, props, requestId) {
        return this.request(stream, {
            action: 'create',
            data: props,
        }, requestId);
    }
    retrieve(stream, pk, data = {}, requestId) {
        return this.request(stream, {
            action: 'retrieve',
            pk,
            data,
        }, requestId);
    }
    update(stream, pk, props, requestId) {
        return this.request(stream, {
            action: 'update',
            pk,
            data: props,
        }, requestId);
    }
    patch(stream, pk, props, requestId) {
        return this.request(stream, {
            action: 'patch',
            pk,
            data: props,
        }, requestId);
    }
    delete(stream, pk, data = {}, requestId) {
        return this.request(stream, {
            action: 'delete',
            pk,
            data,
        }, requestId);
    }
    subscribe(stream, pk, callback, requestId) {
        if (callback == null) {
            throw new Error('callback must be provided');
        }
        if (requestId == null) {
            requestId = UUID_1.default.generate();
        }
        const selector = DCRFClient.buildSubscribeSelector(stream, pk, requestId);
        const handler = this.buildSubscribeListener(callback);
        const payload = DCRFClient.buildSubscribePayload(pk, requestId);
        const listenerId = this.dispatcher.listen(selector, handler);
        const message = DCRFClient.buildMultiplexedMessage(stream, payload);
        this.subscriptions[listenerId] = { selector, handler, message };
        const requestPromise = this.request(stream, payload, requestId);
        const unsubscribe = this.unsubscribe.bind(this, listenerId);
        return new subscriptions_1.SubscriptionPromise((resolve, reject) => {
            requestPromise.then(resolve, reject);
        }, unsubscribe);
    }
    /**
     * Send subscription requests for all registered subscriptions
     */
    resubscribe() {
        const subscriptions = Object.values(this.subscriptions);
        log.info('Resending %d subscription requests', subscriptions.length);
        for (const { message } of subscriptions) {
            this.sendNow(message);
        }
    }
    request(stream, payload, requestId = UUID_1.default.generate()) {
        return new Promise((resolve, reject) => {
            const selector = DCRFClient.buildRequestResponseSelector(stream, requestId);
            this.dispatcher.once(selector, (data) => {
                const { payload: response } = data;
                const responseStatus = response.response_status;
                // 2xx is success
                if (Math.floor(responseStatus / 100) === 2) {
                    resolve(response.data);
                }
                else {
                    reject(response);
                }
            });
            payload = Object.assign({}, payload, { request_id: requestId });
            if (this.options.preprocessPayload != null) {
                // Note: this and the preprocessMessage handler below presume an object will be returned.
                //       If you really want to return a 0, you're kinda SOL -- wrap it in an object :P
                payload = this.options.preprocessPayload(stream, payload, requestId) || payload;
            }
            let message = DCRFClient.buildMultiplexedMessage(stream, payload);
            if (this.options.preprocessMessage != null) {
                message = this.options.preprocessMessage(message) || message;
            }
            this.send(message);
        });
    }
    send(object) {
        return this.doSend(object, this.queue.send);
    }
    sendNow(object) {
        return this.doSend(object, this.queue.sendNow);
    }
    doSend(object, send) {
        const bytes = this.serializer.serialize(object);
        return send(bytes);
    }
    unsubscribe(listenerId) {
        // TODO: send unsubscription message (unsupported by channels-api at time of writing)
        const found = this.subscriptions.hasOwnProperty(listenerId);
        if (found) {
            this.dispatcher.cancel(listenerId);
            delete this.subscriptions[listenerId];
        }
        return found;
    }
    handleTransportMessage(event) {
        const data = this.serializer.deserialize(event.data);
        return this.handleMessage(data);
    }
    handleMessage(data) {
        this.dispatcher.dispatch(data);
    }
    handleTransportConnect() {
        log.debug('Initial API connection over transport %s', this.transport);
        this.queue.processQueue();
    }
    handleTransportReconnect() {
        log.debug('Reestablished API connection');
        this.resubscribe();
        this.queue.processQueue();
    }
    static buildMultiplexedMessage(stream, payload) {
        return { stream, payload };
    }
    static buildRequestResponseSelector(stream, requestId) {
        return {
            stream,
            payload: { request_id: requestId },
        };
    }
    static buildSubscribeSelector(stream, pk, requestId) {
        return {
            stream,
            payload: {
                data: { pk },
                request_id: requestId,
            },
        };
    }
    static buildSubscribePayload(pk, requestId) {
        return {
            action: 'subscribe_instance',
            request_id: requestId,
            pk,
        };
    }
    /**
     * Build a function which will take an entire JSON message and return only
     * the relevant payload (usually an object).
     */
    buildListener(callback) {
        return (data) => {
            return callback(data.payload.data, data);
        };
    }
    /**
     * Build a function which will take an entire JSON message and return only
     * the relevant payload (usually an object).
     */
    buildSubscribeListener(callback) {
        return this.buildListener((data, response) => {
            const action = response.payload.action;
            return callback(data, action);
        });
    }
}
__decorate([
    autobind_decorator_1.default
], DCRFClient.prototype, "handleTransportMessage", null);
__decorate([
    autobind_decorator_1.default
], DCRFClient.prototype, "handleTransportConnect", null);
__decorate([
    autobind_decorator_1.default
], DCRFClient.prototype, "handleTransportReconnect", null);
exports.DCRFClient = DCRFClient;
exports.default = {
    /**
     * Configure a DCRFClient client and begin connection
     *
     * @param url WebSocket URL to connect to
     * @param options Configuration for DCRFClient and ReconnectingWebsocket
     */
    connect(url, options = {}) {
        const client = this.createClient(url, options);
        client.initialize();
        return client;
    },
    /**
     * Create a configured DCRFClient client instance, using default components
     *
     * @param url WebSocket URL to connect to
     * @param options Configuration for DCRFClient and ReconnectingWebsocket
     */
    createClient(url, options = {}) {
        const dispatcher = options.dispatcher || new fifo_1.default();
        const transport = options.transport || new websocket_1.default(url, options.websocket);
        const queue = options.queue || new fifo_2.default();
        const serializer = options.serializer || new json_1.default();
        return new DCRFClient(dispatcher, transport, queue, serializer, options);
    },
};
