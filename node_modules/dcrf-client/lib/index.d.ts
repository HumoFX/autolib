import { DispatchListener, IDCRFOptions, IDispatcher, IMessageEvent, ISendQueue, ISerializer, IStreamingAPI, ITransport, SubscriptionHandler } from './interface';
import { SubscriptionPromise } from './subscriptions';
interface ISubscriptionDescriptor<S, P extends S> {
    selector: S;
    handler: DispatchListener<P>;
    message: object;
}
export declare class DCRFClient implements IStreamingAPI {
    readonly dispatcher: IDispatcher;
    readonly transport: ITransport;
    readonly queue: ISendQueue;
    readonly serializer: ISerializer;
    readonly options: IDCRFOptions;
    readonly subscriptions: {
        [listenerId: number]: ISubscriptionDescriptor<any, any>;
    };
    /**
     * @param dispatcher Dispatcher instance to route incoming frames to associated handlers
     * @param transport Transport to send and receive messages over the wire.
     * @param queue Instance of Queue to queue messages when transport unavailable.
     * @param serializer Instance which handles serializing data to be sent, and
     *                   deserializing received data.
     * @param options Configuration to customize how DCRFClient operates. See
     *                the IDCRFOptions type for more information.
     */
    constructor(dispatcher: IDispatcher, transport: ITransport, queue: ISendQueue, serializer: ISerializer, options?: IDCRFOptions);
    initialize(): void;
    list(stream: string, data?: object, requestId?: string): Promise<any>;
    create(stream: string, props: object, requestId?: string): Promise<any>;
    retrieve(stream: string, pk: number, data?: object, requestId?: string): Promise<any>;
    update(stream: string, pk: number, props: object, requestId?: string): Promise<any>;
    patch(stream: string, pk: number, props: object, requestId?: string): Promise<any>;
    delete(stream: string, pk: number, data?: object, requestId?: string): Promise<any>;
    subscribe(stream: string, pk: number, callback: SubscriptionHandler, requestId?: string): SubscriptionPromise<object>;
    /**
     * Send subscription requests for all registered subscriptions
     */
    resubscribe(): void;
    request(stream: string, payload: object, requestId?: string): Promise<any>;
    send(object: object): number;
    sendNow(object: object): number;
    protected doSend(object: object, send: (bytes: string) => number): number;
    protected unsubscribe(listenerId: number): boolean;
    protected handleTransportMessage(event: IMessageEvent): void;
    protected handleMessage(data: object): void;
    protected handleTransportConnect(): void;
    protected handleTransportReconnect(): void;
    protected static buildMultiplexedMessage(stream: string, payload: object): {
        stream: string;
        payload: object;
    };
    protected static buildRequestResponseSelector(stream: string, requestId: string): {
        stream: string;
        payload: {
            request_id: string;
        };
    };
    protected static buildSubscribeSelector(stream: string, pk: number, requestId: string): {
        stream: string;
        payload: {
            data: {
                pk: number;
            };
            request_id: string;
        };
    };
    protected static buildSubscribePayload(pk: number, requestId: string): {
        action: string;
        request_id: string;
        pk: number;
    };
    /**
     * Build a function which will take an entire JSON message and return only
     * the relevant payload (usually an object).
     */
    protected buildListener(callback: (data: {
        [prop: string]: any;
    }, response: {
        [prop: string]: any;
    }) => void): DispatchListener<{
        payload: {
            data: any;
        };
    }>;
    /**
     * Build a function which will take an entire JSON message and return only
     * the relevant payload (usually an object).
     */
    protected buildSubscribeListener(callback: (data: object, action: string) => void): DispatchListener<{
        payload: {
            data: any;
            action: string;
        };
    }>;
}
declare const _default: {
    /**
     * Configure a DCRFClient client and begin connection
     *
     * @param url WebSocket URL to connect to
     * @param options Configuration for DCRFClient and ReconnectingWebsocket
     */
    connect(url: string, options?: IDCRFOptions): DCRFClient;
    /**
     * Create a configured DCRFClient client instance, using default components
     *
     * @param url WebSocket URL to connect to
     * @param options Configuration for DCRFClient and ReconnectingWebsocket
     */
    createClient(url: string, options?: IDCRFOptions): DCRFClient;
};
export default _default;
